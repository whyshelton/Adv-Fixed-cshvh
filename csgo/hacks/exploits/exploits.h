#pragma once

namespace hacks {
	class c_exploits {
	private:
		int select_type( ) const;
		bool					m_charged{}, m_shift{},
			                    m_force_fake_shift{};
		int						m_ticks_allowed{}, m_cur_shift_amount{},
			m_next_shift_amount{}, m_recharge_cmd{}, m_type{}, m_correction_amount{}, m_prediction_tick{};
		bool m_allow_choke{}, m_in_charge{}, m_defensive_allowed{};

	public:
		void manage_wpn( valve::user_cmd_t& user_cmd );

		bool try_to_recharge( valve::user_cmd_t& user_cmd );

		bool is_peeking( sdk::qang_t& angle, float ticks );

		int calc_correction_ticks( ) const;

		void skip_lag_interpolation( bool process );

		int adjust_tick_base(
			const int old_new_cmds,
			const int total_new_cmds, const int delta
		) const;

		int server_tick( ) const;

		void handle_break_lc(
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
		);

		void process_real_cmds(
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
		);

		ALWAYS_INLINE bool& charged( );

		ALWAYS_INLINE bool& shift( );

		ALWAYS_INLINE int& type( );

		ALWAYS_INLINE bool& in_charge( );

		ALWAYS_INLINE bool& allow_choke( );

		ALWAYS_INLINE int& correction_amount( );

		ALWAYS_INLINE int& ticks_allowed( );

		ALWAYS_INLINE int& cur_shift_amount( );

		ALWAYS_INLINE int& next_shift_amount( );

		ALWAYS_INLINE int& recharge_cmd( );

		ALWAYS_INLINE bool& defensive_allowed( );
	};

	inline const auto g_exploits = std::make_unique < c_exploits >( );
}

#include "impl/exploits.inl"