#include "../../../csgo.hpp"

namespace hacks {
    int c_exploits::select_type( ) const {
        if ( !g_local_player->self ( )
             || g_move->should_fake_duck( ) )
            return 0;

        if ( g_key_binds->get_keybind_state( &g_menu->main( ).m_exploits_cfg.get( ).m_double_tap ) )
            return 3;

        if ( g_key_binds->get_keybind_state( &g_menu->main( ).m_exploits_cfg.get( ).m_hide_shots ) )
            return 1;

        return 0;
    }

    bool c_exploits::is_peeking( sdk::qang_t& angle, float ticks ) {
        bool player_found = false;

        if ( !g_local_player->self( ) ||
            !g_local_player->self( )->weapon( ) )
            return false;

        if ( g_local_player->self( )->velocity( ).length( 2u ) < 7.f )
            return false;

        for ( int i = 1; i <= valve::g_global_vars.get( )->m_max_clients; ++i )
        {
            auto entry = hacks::g_lag_comp->entry( i - 1 );

            if ( !g_local_player->self( ) || !g_local_player->self( )->alive( ) )
                continue;

            if ( !entry.m_player || !entry.m_player->alive( )
                || entry.m_player == g_local_player->self( ) || entry.m_player->networkable( )->dormant( ) || entry.m_player->friendly( g_local_player->self( ) ) )
                continue;

            if ( entry.m_lag_records.empty( ) )
                continue;

            auto& lag_record = entry.m_lag_records.back( );

            if ( !lag_record )
                continue;

            aim_target_t target{};

            target.m_entry = const_cast< player_entry_t* >( &entry );
            target.m_lag_record = lag_record;

            sdk::vec3_t next_shot_pos = g_local_player->shoot_pos( ) + ( g_local_player->self( )->velocity( ) * valve::g_global_vars.get( )->m_interval_per_tick ) * ticks;
            g_aim_bot->scan_points( target, ( 1 << 1 | 1 << 3 | 1 << 4 ), ( 1 << 1 | 1 << 3 | 1 << 4 ), true, next_shot_pos );

            if ( g_aim_bot->select_points( target, false ) ) {
                player_found = true;
                break;
            }
        }

        return player_found;
    }

	void c_exploits::manage_wpn( valve::user_cmd_t& user_cmd ) {
		const auto weapon = g_local_player->weapon ( );
		const auto wpn_data = weapon ? g_local_player->weapon_info ( ) : nullptr;

        int shift_amount{};

        if ( ( m_type = select_type( ) ) ) {
            if ( weapon ) {
                const auto item_index = weapon->item_index( );
                if ( item_index != valve::e_item_index::taser
                    && item_index != valve::e_item_index::c4
                    && !( item_index >= valve::e_item_index::flashbang && item_index <= valve::e_item_index::inc_grenade ) ) {
                    if ( m_ticks_allowed ) {
                        if ( m_type == 1 )
                            shift_amount = 8;
                        else if ( m_type == 2 || m_type == 3 ) {
                            if ( g_local_player->can_shoot( false, 0, false ) )
                                shift_amount = m_ticks_allowed;
                        }

                        if ( valve::g_global_vars.get( )->m_cur_time >= g_local_player->self( )->next_attack( ) ) {
                            m_next_shift_amount = shift_amount;
                        }

                        goto SKIP;
                    }
                }
            }
        };

        shift_amount = m_cur_shift_amount = m_next_shift_amount = 0;
        if ( !m_type
            && m_ticks_allowed > 0 ) {
            m_type = 4;
            m_cur_shift_amount = m_next_shift_amount = m_ticks_allowed;

            m_charged = true;
        }

    SKIP:
        if ( weapon
            && weapon->item_index( ) == valve::e_item_index::revolver ) {
            g_local_player->prediction( ).data( ).r8_can_shoot( ) = true;

            user_cmd.m_buttons &= ~valve::e_buttons::in_attack2;

            if ( g_local_player->can_shoot( true, 0, true ) ) {
                if ( valve::g_global_vars.get( )->m_cur_time < g_local_player->prediction( ).data( ).postpone_fire_ready_time( ) )
                    user_cmd.m_buttons |= valve::e_buttons::in_attack;
                else if ( valve::g_global_vars.get( )->m_cur_time < weapon->next_secondary_attack( ) )
                    user_cmd.m_buttons |= valve::e_buttons::in_attack2;
                else
                    g_local_player->prediction( ).data( ).postpone_fire_ready_time( ) = valve::g_global_vars.get( )->m_cur_time + 0.234375f;

                g_local_player->prediction( ).data( ).r8_can_shoot( ) = valve::g_global_vars.get( )->m_cur_time > g_local_player->prediction( ).data( ).postpone_fire_ready_time( );
            }
            else {
                user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

                g_local_player->prediction( ).data( ).postpone_fire_ready_time( ) = valve::g_global_vars.get( )->m_cur_time + 0.234375f;

                g_local_player->prediction( ).data( ).r8_can_shoot( ) = false;
            }
        }

        if ( ( m_charged || m_shift )
            && ( user_cmd.m_buttons & valve::e_buttons::in_attack )
            && wpn_data->m_type != valve::e_weapon_type::grenade )
            user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

        m_in_charge = false;

        if ( g_local_player->prediction( ).data( ).shot_valid_wpn( )
            && g_local_player->prediction( ).data( ).shot_cmd_number( ) > valve::g_client_state->m_last_cmd_out
            && g_local_player->prediction( ).data( ).shot_cmd_number( ) < ( valve::g_client_state->m_last_cmd_out + 100 ) )
            m_in_charge = true;

        if ( m_charged )
            m_allow_choke = false;
        else if ( !m_shift ) {
            if ( m_type
                && m_ticks_allowed ) {
                if ( valve::g_client_state->m_net_chan->m_choked_packets >= 1 )
                    m_allow_choke = false;
                else
                    m_allow_choke = true;
            }
            else {
                if ( valve::g_client_state->m_net_chan->m_choked_packets >= 14 )
                    m_allow_choke = false;
                else
                    m_allow_choke = true;
            }
        }
        else
            m_allow_choke = true;

        if ( ( m_charged || m_shift )
            && ( user_cmd.m_buttons & valve::e_buttons::in_attack )
            && wpn_data->m_type != valve::e_weapon_type::grenade )
            user_cmd.m_buttons &= ~valve::e_buttons::in_attack; 

        if ( g_local_player->can_shoot( false, 0, false ) )
            g_local_player->can_shoot( ) = true;
        else
            g_local_player->can_shoot( ) = false;
	}

    bool c_exploits::try_to_recharge( valve::user_cmd_t& user_cmd ) {
        if ( ( valve::g_global_vars.get( )->m_cur_time - g_local_player->self( )->spawn_time( ) ) < 1.f )
            return false;

        if ( hacks::g_aim_bot->stop_type( ) )
            return false;

        if ( m_recharge_cmd != valve::g_client_state->m_last_cmd_out
            && ( valve::g_client_state->m_choked_cmds || m_ticks_allowed >= 14 ) )
            return false;

        if ( !select_type( )
            || std::abs( g_local_player->prediction( ).data( ).last_shot_time( ) - valve::g_global_vars.get( )->m_cur_time ) < 0.30f )
            return false;

        if ( m_ticks_allowed >= 14 ) {
            m_charged = true;

            if ( ( m_ticks_allowed + 1 ) <= 16 ) {
                if ( m_ticks_allowed < 0 )
                    m_ticks_allowed = 0;
            }
            else
                m_ticks_allowed = 14;

            return false;
        }

        m_recharge_cmd = valve::g_client_state->m_last_cmd_out;

        if ( ++m_ticks_allowed > 16 )
            m_ticks_allowed = 16;

        return true;
    }

    int c_exploits::calc_correction_ticks( ) const {
        static auto sv_clockcorrection_msecs = valve::g_cvar->find_var( ( "sv_clockcorrection_msecs" ) );
        return valve::g_global_vars.get( )->m_max_clients <= 1
            ? -1 : valve::to_ticks( std::clamp( sv_clockcorrection_msecs->get_float( ) / 1000.f, 0.f, 1.f ) );
    }

    void c_exploits::skip_lag_interpolation( bool process ) {
        if ( !g_local_player->self( ) || !g_local_player->self( )->alive( ) )
            return;

        if ( m_recharge_cmd != valve::g_client_state->m_last_cmd_out )
            return;

        if ( !process )
        {
            m_prediction_tick = g_local_player->self( )->final_pred_tick( );

            g_local_player->self( )->final_pred_tick( ) = valve::g_global_vars.get( )->m_tick_count + valve::to_ticks( valve::g_client_state->m_net_chan->latency( valve::e_net_flow::out ) + valve::g_client_state->m_net_chan->latency( valve::e_net_flow::in ) );
            return;
        }

        g_local_player->self( )->final_pred_tick( ) = m_prediction_tick;
    }

    int c_exploits::server_tick( ) const {
        return std::numeric_limits< int >::max( );
    }

    int c_exploits::adjust_tick_base(
        const int old_new_cmds,
        const int total_new_cmds, const int delta
    ) const {
        auto ret = -1;

        const auto correction_ticks = calc_correction_ticks( );
        if ( correction_ticks != -1 ) {
            const auto& prev_local_data = g_local_player->prediction( ).data ( ).local_data( ).at( valve::g_client_state->m_last_cmd_out % 150 );
            if ( prev_local_data.m_spawn_time == g_local_player->self( )->spawn_time( ) ) {
                ret = prev_local_data.m_tick_base + 1;

                const auto tick_count = ret + old_new_cmds - m_correction_amount;

                const auto ideal_final_tick = tick_count + correction_ticks;

                const auto too_fast_limit = ideal_final_tick + correction_ticks;
                const auto too_slow_limit = ideal_final_tick - correction_ticks;

                const auto adjusted_final_tick = ret + total_new_cmds;

                if ( adjusted_final_tick > too_fast_limit
                    || adjusted_final_tick < too_slow_limit ) {
                    ret = ideal_final_tick - total_new_cmds;
                }
            }
        }

        if ( ret != -1 )
            return ret;

        const auto& local_data = g_local_player->prediction( ).data( ).local_data( ).at( ( valve::g_client_state->m_last_cmd_out + 1 ) % 150 );

        return ( local_data.m_spawn_time == g_local_player->self( )->spawn_time( )
            ? local_data.m_tick_base : g_local_player->self( )->tick_base( ) ) - delta;
    }

    void c_exploits::handle_break_lc(
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
    ) {
        auto shift_amount = m_cur_shift_amount;

        m_cur_shift_amount = 0;

        const auto v86 = std::min( move_msg->m_new_cmds + m_ticks_allowed, 16 );

        int v69{};

        const auto v70 = v86 - move_msg->m_new_cmds;
        if ( v70 >= 0 )
            v69 = v70;

        m_ticks_allowed = v69;

        const auto old_new_cmds = move_msg->m_new_cmds;

        move_msg->m_new_cmds = std::clamp( move_msg->m_new_cmds + shift_amount, 1, 62 );
        move_msg->m_backup_cmds = 0;

        const auto next_cmd_number = valve::g_client_state->m_last_cmd_out + valve::g_client_state->m_choked_cmds + 1;

        for ( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if ( !hooks::o_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer, from, to, true ) )
                return;

            from = to;
        }

        for ( auto i = valve::g_client_state->m_last_cmd_out + 1; i <= next_cmd_number; ++i )
            g_local_player->prediction( ).data( ).local_data( ).at( i % 150 ).m_shift_amount = shift_amount;

        const auto user_cmd = valve::g_input->user_cmd( slot, from );
        if ( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        if ( shift_amount ) {
            ++to_user_cmd.m_number;

            to_user_cmd.m_tick = std::numeric_limits< int >::max( );

            do {
                buffer->write_user_cmd( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;

                --shift_amount;
            } while ( shift_amount );     
        }
    }

    __forceinline bool is_zero_vec3_t( sdk::vec3_t vec ) {
        return ( vec.x( ) > -0.01f && vec.x( ) < 0.01f &&
            vec.y( ) > -0.01f && vec.y( ) < 0.01f &&
            vec.z( ) > -0.01f && vec.z( ) < 0.01f );
    }

    void c_exploits::process_real_cmds(
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
         valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
    ) {
        auto shift_amount = m_cur_shift_amount;

        m_cur_shift_amount = 0;

        const auto write_real_cmds = m_type == 3 || m_type == 4;

        const auto v86 = std::min( move_msg->m_new_cmds + m_ticks_allowed, 16 );

        int v69{};

        auto v70 = v86 - move_msg->m_new_cmds;
        if ( write_real_cmds )
            v70 -= shift_amount;

        if ( v70 >= 0 )
            v69 = v70;

        m_ticks_allowed = v69;

        const auto old_new_cmds = move_msg->m_new_cmds;

        move_msg->m_new_cmds = std::clamp( move_msg->m_new_cmds + shift_amount, 1, 62 );
        move_msg->m_backup_cmds = 0;

        auto first_tick_base = adjust_tick_base( old_new_cmds, move_msg->m_new_cmds, shift_amount );

        const auto next_cmd_number = valve::g_client_state->m_last_cmd_out + valve::g_client_state->m_choked_cmds + 1;

        for ( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if ( !hooks::o_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer, from, to, true ) )
                return;

            from = to;
        }

        for ( auto i = valve::g_client_state->m_last_cmd_out + 1; i <= next_cmd_number; ++i ) {
            auto& local_data = g_local_player->prediction( ).data( ).local_data( ).at( i % 150 );

            local_data.m_shift_amount = write_real_cmds ? 0 : shift_amount;
            local_data.m_override_tick_base = true;
            local_data.m_restore_tick_base = write_real_cmds ? local_data.m_restore_tick_base : true;
            local_data.m_adjusted_tick_base = first_tick_base++;
        }

        const auto user_cmd = valve::g_input->user_cmd( slot, from );
        if ( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        ++to_user_cmd.m_number;

        valve::g_prediction.get( )->m_prev_start_frame = -1;
        valve::g_prediction.get( )->m_cmds_predicted = 0;

        sdk::vec2_t target_move{};

        if ( write_real_cmds ) {
            ++valve::g_client_state->m_choked_cmds;
            ++valve::g_client_state->m_net_chan->m_choked_packets;
            ++valve::g_client_state->m_net_chan->m_out_seq;

            const auto& local_data = g_local_player->prediction( ).data( ).local_data( ).at( next_cmd_number % 150 );
            target_move = { local_data.m_move.x( ), local_data.m_move.y( ) };

            int shifted_cmds{};

            do {
                g_local_player->prediction( ).process_prediction( &to_user_cmd );

                to_user_cmd.m_buttons &= static_cast< valve::e_buttons >( ~4290707449u );
                to_user_cmd.m_move = {};
                if ( g_local_player->self( )->alive( ) ) {
                    if ( m_type != 4
                        && !( to_user_cmd.m_buttons & valve::e_buttons::in_jump )
                        && g_local_player->self( )->flags( ) & valve::e_ent_flags::on_ground ) {
                        int v17{};
                        if ( ( shift_amount - 2 ) >= 0 )
                            v17 = shift_amount - 1;

                        static sdk::qang_t wtf{};

                        if ( shifted_cmds >= v17 ) {
                            hacks::g_aim_bot->stop_type( ) = 2;
                            hacks::g_move->auto_stop( to_user_cmd );
                        }
                        else {
                            to_user_cmd.m_move.x( ) = target_move.x( );
                            to_user_cmd.m_move.y( ) = target_move.y( );
                        }
                    }

                    if ( m_type == 4 ) {
                        to_user_cmd.m_move.x( ) = target_move.x( );
                        to_user_cmd.m_move.y( ) = target_move.y( );

                    }

                    if ( !is_zero_vec3_t( hacks::g_move->auto_peek_data( ).m_pos ) && m_type == 3 )
                    {
                        auto angle = sdk::calc_ang( g_local_player->self( )->abs_origin( ), hacks::g_move->auto_peek_data( ).m_pos );
                        to_user_cmd.m_view_angles.y( ) = angle.y( );
                        to_user_cmd.m_move.x( ) =  450.f;
                        to_user_cmd.m_move.y( ) = 0.f;
                    } 

                    g_local_player->anim_sync( ).update_local_real( to_user_cmd, shifted_cmds >= shift_amount );

                }

                valve::g_input->m_cmds[ to_user_cmd.m_number % 150 ] = to_user_cmd;
                valve::g_input->m_vfyd_cmds[ to_user_cmd.m_number % 150 ] = { to_user_cmd, to_user_cmd.checksum( ) };

                buffer->write_user_cmd( &to_user_cmd, &from_user_cmd );

                auto& local_data = g_local_player->prediction( ).data( ).local_data( ).at( to_user_cmd.m_number % 150 );

                local_data.m_override_tick_base = true;
                local_data.m_adjusted_tick_base = first_tick_base++;

                ++shifted_cmds;

                if ( shifted_cmds >= shift_amount ) {
                    if ( to_user_cmd.m_tick != std::numeric_limits < float >::max( ) ) {
                        const auto i_cant_code{ true };
                        g_local_player->net_data( ).add_net_cmd( valve::g_client_state->m_last_cmd_out + valve::g_client_state->m_choked_cmds + 1, i_cant_code );
                    }
                }
                else {
                    ++valve::g_client_state->m_choked_cmds;
                    ++valve::g_client_state->m_net_chan->m_choked_packets;
                    ++valve::g_client_state->m_net_chan->m_out_seq;
                }

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;
            } while ( shifted_cmds < shift_amount );

        }
        else {
            to_user_cmd.m_tick = std::numeric_limits< int >::max( );

            do {
                buffer->write_user_cmd( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;

                --shift_amount;
            } while ( shift_amount );
        }
    }
}